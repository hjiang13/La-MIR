Compilation and Execution Results
=================================

CPP_109.cpp: Compilation Failed
Error: In file included from ./CPP_109.cpp:46:
./CPP_109.cpp: In function ‘int main()’:
./CPP_109.cpp:48:26: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   48 |     assert (move_one_ball({3, 4, 5, 1, 2})==true);
      |             ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/13/vector:66,
                 from ./CPP_109.cpp:1:
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_109.cpp:6:33: note:   initializing argument 1 of ‘bool move_one_ball(std::vector<int>&)’
    6 | bool move_one_ball(vector<int>& balls) {
      |                    ~~~~~~~~~~~~~^~~~~
./CPP_109.cpp:49:26: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   49 |     assert (move_one_ball({3, 5, 10, 1, 2})==true);
      |             ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_109.cpp:6:33: note:   initializing argument 1 of ‘bool move_one_ball(std::vector<int>&)’
    6 | bool move_one_ball(vector<int>& balls) {
      |                    ~~~~~~~~~~~~~^~~~~
./CPP_109.cpp:50:26: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   50 |     assert (move_one_ball({4, 3, 1, 2})==false);
      |             ~~~~~~~~~~~~~^~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_109.cpp:6:33: note:   initializing argument 1 of ‘bool move_one_ball(std::vector<int>&)’
    6 | bool move_one_ball(vector<int>& balls) {
      |                    ~~~~~~~~~~~~~^~~~~
./CPP_109.cpp:51:26: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   51 |     assert (move_one_ball({3, 5, 4, 1, 2})==false);
      |             ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_109.cpp:6:33: note:   initializing argument 1 of ‘bool move_one_ball(std::vector<int>&)’
    6 | bool move_one_ball(vector<int>& balls) {
      |                    ~~~~~~~~~~~~~^~~~~
./CPP_109.cpp:52:26: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   52 |     assert (move_one_ball({})==true);
      |             ~~~~~~~~~~~~~^~~~
/usr/include/c++/13/bits/stl_vector.h:531:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = int; _Alloc = std::allocator<int>]’
  531 |       vector() = default;
      |       ^~~~~~
./CPP_109.cpp:6:33: note:   initializing argument 1 of ‘bool move_one_ball(std::vector<int>&)’
    6 | bool move_one_ball(vector<int>& balls) {
      |                    ~~~~~~~~~~~~~^~~~~


CPP_138.cpp: Compilation Failed
Error: ./CPP_138.cpp:18:5: error: redefinition of ‘int main()’
   18 | int main(){
      |     ^~~~
./CPP_138.cpp:7:5: note: ‘int main()’ previously defined here
    7 | int main() {
      |     ^~~~


CPP_12.cpp: Compilation Failed
Error: ./CPP_12.cpp: In function ‘void longest(std::vector<std::__cxx11::basic_string<char> >*, std::string*)’:
./CPP_12.cpp:13:23: error: ‘uint64_t’ does not name a type
   13 |     *reinterpret_cast<uint64_t*>(data_ptr) = 0; // Initialize string's length
      |                       ^~~~~~~~
./CPP_12.cpp:3:1: note: ‘uint64_t’ is defined in header ‘<cstdint>’; did you forget to ‘#include <cstdint>’?
    2 | #include <string>
  +++ |+#include <cstdint>
    3 | 
./CPP_12.cpp:13:31: error: expected ‘>’ before ‘*’ token
   13 |     *reinterpret_cast<uint64_t*>(data_ptr) = 0; // Initialize string's length
      |                               ^
./CPP_12.cpp:13:31: error: expected ‘(’ before ‘*’ token
   13 |     *reinterpret_cast<uint64_t*>(data_ptr) = 0; // Initialize string's length
      |                               ^
      |                               (
./CPP_12.cpp:13:32: error: expected primary-expression before ‘>’ token
   13 |     *reinterpret_cast<uint64_t*>(data_ptr) = 0; // Initialize string's length
      |                                ^
./CPP_12.cpp:13:47: error: expected ‘)’ before ‘;’ token
   13 |     *reinterpret_cast<uint64_t*>(data_ptr) = 0; // Initialize string's length
      |                                               ^
      |                                               )
./CPP_12.cpp:14:23: error: ‘uint64_t’ does not name a type
   14 |     *reinterpret_cast<uint64_t*>(data_ptr + 8) = 0; // Initialize string's capacity
      |                       ^~~~~~~~
./CPP_12.cpp:14:23: note: ‘uint64_t’ is defined in header ‘<cstdint>’; did you forget to ‘#include <cstdint>’?
./CPP_12.cpp:14:31: error: expected ‘>’ before ‘*’ token
   14 |     *reinterpret_cast<uint64_t*>(data_ptr + 8) = 0; // Initialize string's capacity
      |                               ^
./CPP_12.cpp:14:31: error: expected ‘(’ before ‘*’ token
   14 |     *reinterpret_cast<uint64_t*>(data_ptr + 8) = 0; // Initialize string's capacity
      |                               ^
      |                               (
./CPP_12.cpp:14:32: error: expected primary-expression before ‘>’ token
   14 |     *reinterpret_cast<uint64_t*>(data_ptr + 8) = 0; // Initialize string's capacity
      |                                ^
./CPP_12.cpp:14:51: error: expected ‘)’ before ‘;’ token
   14 |     *reinterpret_cast<uint64_t*>(data_ptr + 8) = 0; // Initialize string's capacity
      |                                                   ^
      |                                                   )
./CPP_12.cpp:16:5: error: ‘uint64_t’ was not declared in this scope
   16 |     uint64_t max_length = 0;
      |     ^~~~~~~~
./CPP_12.cpp:16:5: note: ‘uint64_t’ is defined in header ‘<cstdint>’; did you forget to ‘#include <cstdint>’?
./CPP_12.cpp:20:17: error: expected ‘;’ before ‘length’
   20 |         uint64_t length = reinterpret_cast<uint64_t>(str) & 0xFFFFFFFFFFFF;
      |                 ^~~~~~~
      |                 ;
./CPP_12.cpp:21:13: error: ‘length’ was not declared in this scope
   21 |         if (length > max_length) {
      |             ^~~~~~
./CPP_12.cpp:21:22: error: ‘max_length’ was not declared in this scope
   21 |         if (length > max_length) {
      |                      ^~~~~~~~~~
In file included from ./CPP_12.cpp:33:
./CPP_12.cpp: In function ‘int main()’:
./CPP_12.cpp:35:20: error: too few arguments to function ‘void longest(std::vector<std::__cxx11::basic_string<char> >*, std::string*)’
   35 |     assert (longest({}) == "");
      |             ~~~~~~~^~~~
./CPP_12.cpp:6:6: note: declared here
    6 | void longest(vector<string> *vec, string *sret) {
      |      ^~~~~~~
./CPP_12.cpp:36:20: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<std::__cxx11::basic_string<char> >*’
   36 |     assert (longest({"x", "y", "z"}) == "x");
      |             ~~~~~~~^~~~~~~~~~~~~~~~~
      |                    |
      |                    <brace-enclosed initializer list>
./CPP_12.cpp:6:30: note:   initializing argument 1 of ‘void longest(std::vector<std::__cxx11::basic_string<char> >*, std::string*)’
    6 | void longest(vector<string> *vec, string *sret) {
      |              ~~~~~~~~~~~~~~~~^~~
./CPP_12.cpp:37:20: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<std::__cxx11::basic_string<char> >*’
   37 |     assert (longest({"x", "yyy", "zzzz", "www", "kkkk", "abc"}) == "zzzz");
      |             ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                    |
      |                    <brace-enclosed initializer list>
./CPP_12.cpp:6:30: note:   initializing argument 1 of ‘void longest(std::vector<std::__cxx11::basic_string<char> >*, std::string*)’
    6 | void longest(vector<string> *vec, string *sret) {
      |              ~~~~~~~~~~~~~~~~^~~


CPP_42.cpp: Compilation Failed
Error: ./CPP_42.cpp: In function ‘void incr_list(std::vector<int>&, const std::vector<int>&)’:
./CPP_42.cpp:27:13: error: ‘__m128i’ was not declared in this scope
   27 |             __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(chunk_start));
      |             ^~~~~~~
./CPP_42.cpp:28:20: error: expected ‘;’ before ‘incremented’
   28 |             __m128i incremented = _mm_add_epi32(vec, _mm_set1_epi32(1));
      |                    ^~~~~~~~~~~~
      |                    ;
./CPP_42.cpp:29:47: error: ‘__m128i’ does not name a type
   29 |             _mm_storeu_si128(reinterpret_cast<__m128i*>(output_chunk), incremented);
      |                                               ^~~~~~~
./CPP_42.cpp:29:54: error: expected ‘>’ before ‘*’ token
   29 |             _mm_storeu_si128(reinterpret_cast<__m128i*>(output_chunk), incremented);
      |                                                      ^
./CPP_42.cpp:29:54: error: expected ‘(’ before ‘*’ token
   29 |             _mm_storeu_si128(reinterpret_cast<__m128i*>(output_chunk), incremented);
      |                                                      ^
      |                                                      (
./CPP_42.cpp:29:55: error: expected primary-expression before ‘>’ token
   29 |             _mm_storeu_si128(reinterpret_cast<__m128i*>(output_chunk), incremented);
      |                                                       ^
./CPP_42.cpp:29:72: error: ‘incremented’ was not declared in this scope
   29 |             _mm_storeu_si128(reinterpret_cast<__m128i*>(output_chunk), incremented);
      |                                                                        ^~~~~~~~~~~
./CPP_42.cpp:35:25: error: ‘chunk_start’ was not declared in this scope
   35 |             output_data[chunk_start + i] = data[chunk_start + i] + 1;
      |                         ^~~~~~~~~~~
./CPP_42.cpp: At global scope:
./CPP_42.cpp:48:13: error: ‘vector’ was not declared in this scope
   48 | bool issame(vector<int> a,vector<int>b){
      |             ^~~~~~
./CPP_42.cpp:48:13: note: suggested alternatives:
In file included from /usr/include/c++/13/vector:66,
                 from ./CPP_42.cpp:1:
/usr/include/c++/13/bits/stl_vector.h:428:11: note:   ‘std::vector’
  428 |     class vector : protected _Vector_base<_Tp, _Alloc>
      |           ^~~~~~
/usr/include/c++/13/vector:86:13: note:   ‘std::pmr::vector’
   86 |       using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
      |             ^~~~~~
./CPP_42.cpp:48:20: error: expected primary-expression before ‘int’
   48 | bool issame(vector<int> a,vector<int>b){
      |                    ^~~
./CPP_42.cpp:48:27: error: ‘vector’ was not declared in this scope
   48 | bool issame(vector<int> a,vector<int>b){
      |                           ^~~~~~
./CPP_42.cpp:48:27: note: suggested alternatives:
/usr/include/c++/13/bits/stl_vector.h:428:11: note:   ‘std::vector’
  428 |     class vector : protected _Vector_base<_Tp, _Alloc>
      |           ^~~~~~
/usr/include/c++/13/vector:86:13: note:   ‘std::pmr::vector’
   86 |       using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
      |             ^~~~~~
./CPP_42.cpp:48:34: error: expected primary-expression before ‘int’
   48 | bool issame(vector<int> a,vector<int>b){
      |                                  ^~~
./CPP_42.cpp:48:39: error: expression list treated as compound expression in initializer [-fpermissive]
   48 | bool issame(vector<int> a,vector<int>b){
      |                                       ^
In file included from ./CPP_42.cpp:47:
./CPP_42.cpp: In function ‘int main()’:
./CPP_42.cpp:57:29: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   57 |     assert (issame(incr_list({}) , {}));
      |                    ~~~~~~~~~^~~~
/usr/include/c++/13/bits/stl_vector.h:531:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = int; _Alloc = std::allocator<int>]’
  531 |       vector() = default;
      |       ^~~~~~
./CPP_42.cpp:4:34: note: in passing argument 1 of ‘void incr_list(std::vector<int>&, const std::vector<int>&)’
    4 | void incr_list(std::vector<int>& output, const std::vector<int>& input) {
      |                ~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_42.cpp:57:19: error: ‘issame’ cannot be used as a function
   57 |     assert (issame(incr_list({}) , {}));
      |             ~~~~~~^~~~~~~~~~~~~~~~~~~~
./CPP_42.cpp:58:29: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   58 |     assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));
      |                    ~~~~~~~~~^~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_42.cpp:4:34: note: in passing argument 1 of ‘void incr_list(std::vector<int>&, const std::vector<int>&)’
    4 | void incr_list(std::vector<int>& output, const std::vector<int>& input) {
      |                ~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_42.cpp:58:19: error: ‘issame’ cannot be used as a function
   58 |     assert (issame(incr_list({3, 2, 1}) , {4, 3, 2}));
      |             ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_42.cpp:59:29: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   59 |     assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));
      |                    ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_42.cpp:4:34: note: in passing argument 1 of ‘void incr_list(std::vector<int>&, const std::vector<int>&)’
    4 | void incr_list(std::vector<int>& output, const std::vector<int>& input) {
      |                ~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_42.cpp:59:19: error: ‘issame’ cannot be used as a function
   59 |     assert (issame(incr_list({5, 2, 5, 2, 3, 3, 9, 0, 123}) , {6, 3, 6, 3, 4, 4, 10, 1, 124}));
      |             ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


CPP_121.cpp: Compilation Failed
Error: In file included from ./CPP_121.cpp:39:
./CPP_121.cpp: In function ‘int main()’:
./CPP_121.cpp:41:13: error: ‘solutions’ was not declared in this scope; did you mean ‘solution’?
   41 |     assert (solutions({5, 8, 7, 1})    == 12);
      |             ^~~~~~~~~


CPP_80.cpp: Execution Failed
Error: CPP_80: ./CPP_80.cpp:24: int main(): Assertion `is_happy("abcd") == true' failed.
Aborted (core dumped)


CPP_60.cpp: Compilation Failed
Error: ./CPP_60.cpp:16:5: error: redefinition of ‘int main()’
   16 | int main(){
      |     ^~~~
./CPP_60.cpp:7:5: note: ‘int main()’ previously defined here
    7 | int main() {
      |     ^~~~


CPP_139.cpp: Execution Failed
Error: CPP_139: ./CPP_139.cpp:18: int main(): Assertion `special_factorial(4) == 288' failed.
Aborted (core dumped)


CPP_63.cpp: Compilation Failed
Error: ./CPP_63.cpp:44:5: error: redefinition of ‘int main()’
   44 | int main(){
      |     ^~~~
./CPP_63.cpp:34:5: note: ‘int main()’ previously defined here
   34 | int main() {
      |     ^~~~
In file included from ./CPP_63.cpp:43:
./CPP_63.cpp: In function ‘int main()’:
./CPP_63.cpp:45:13: error: ‘fibfib’ was not declared in this scope
   45 |     assert (fibfib(2) == 1);
      |             ^~~~~~


CPP_159.cpp: Compilation Failed
Error: ./CPP_159.cpp: In function ‘void eat(std::vector<int>*, int, int, int)’:
./CPP_159.cpp:24:12: error: ‘std::_Vector_base<int, std::allocator<int> >::_Vector_impl std::_Vector_base<int, std::allocator<int> >::_M_impl’ is inaccessible within this context
   24 |         v->_M_impl._M_start = data;
      |            ^~~~~~~
In file included from /usr/include/c++/13/vector:66,
                 from ./CPP_159.cpp:1:
/usr/include/c++/13/bits/stl_vector.h:374:20: note: declared here
  374 |       _Vector_impl _M_impl;
      |                    ^~~~~~~
./CPP_159.cpp:25:12: error: ‘std::_Vector_base<int, std::allocator<int> >::_Vector_impl std::_Vector_base<int, std::allocator<int> >::_M_impl’ is inaccessible within this context
   25 |         v->_M_impl._M_end_of_storage = data + 8;
      |            ^~~~~~~
/usr/include/c++/13/bits/stl_vector.h:374:20: note: declared here
  374 |       _Vector_impl _M_impl;
      |                    ^~~~~~~
./CPP_159.cpp:26:12: error: ‘std::_Vector_base<int, std::allocator<int> >::_Vector_impl std::_Vector_base<int, std::allocator<int> >::_M_impl’ is inaccessible within this context
   26 |         v->_M_impl._M_end = data + 4;
      |            ^~~~~~~
/usr/include/c++/13/bits/stl_vector.h:374:20: note: declared here
  374 |       _Vector_impl _M_impl;
      |                    ^~~~~~~
./CPP_159.cpp:26:20: error: ‘struct std::_Vector_base<int, std::allocator<int> >::_Vector_impl’ has no member named ‘_M_end’
   26 |         v->_M_impl._M_end = data + 4;
      |                    ^~~~~~
./CPP_159.cpp:46:12: error: ‘std::_Vector_base<int, std::allocator<int> >::_Vector_impl std::_Vector_base<int, std::allocator<int> >::_M_impl’ is inaccessible within this context
   46 |         v->_M_impl._M_start = data;
      |            ^~~~~~~
/usr/include/c++/13/bits/stl_vector.h:374:20: note: declared here
  374 |       _Vector_impl _M_impl;
      |                    ^~~~~~~
./CPP_159.cpp:47:12: error: ‘std::_Vector_base<int, std::allocator<int> >::_Vector_impl std::_Vector_base<int, std::allocator<int> >::_M_impl’ is inaccessible within this context
   47 |         v->_M_impl._M_end_of_storage = data + 8;
      |            ^~~~~~~
/usr/include/c++/13/bits/stl_vector.h:374:20: note: declared here
  374 |       _Vector_impl _M_impl;
      |                    ^~~~~~~
./CPP_159.cpp:48:12: error: ‘std::_Vector_base<int, std::allocator<int> >::_Vector_impl std::_Vector_base<int, std::allocator<int> >::_M_impl’ is inaccessible within this context
   48 |         v->_M_impl._M_end = data + 4;
      |            ^~~~~~~
/usr/include/c++/13/bits/stl_vector.h:374:20: note: declared here
  374 |       _Vector_impl _M_impl;
      |                    ^~~~~~~
./CPP_159.cpp:48:20: error: ‘struct std::_Vector_base<int, std::allocator<int> >::_Vector_impl’ has no member named ‘_M_end’
   48 |         v->_M_impl._M_end = data + 4;
      |                    ^~~~~~
In file included from ./CPP_159.cpp:56:
./CPP_159.cpp: In function ‘int main()’:
./CPP_159.cpp:66:24: error: invalid conversion from ‘int’ to ‘std::vector<int>*’ [-fpermissive]
   66 |     assert (issame(eat(5, 6, 10) , {11, 4}));
      |                        ^
      |                        |
      |                        int
./CPP_159.cpp:66:23: error: too few arguments to function ‘void eat(std::vector<int>*, int, int, int)’
   66 |     assert (issame(eat(5, 6, 10) , {11, 4}));
      |                    ~~~^~~~~~~~~~
./CPP_159.cpp:7:6: note: declared here
    7 | void eat(vector<int>* v, int a, int b, int c) {
      |      ^~~
./CPP_159.cpp:67:24: error: invalid conversion from ‘int’ to ‘std::vector<int>*’ [-fpermissive]
   67 |     assert (issame(eat(4, 8, 9) , {12, 1}));
      |                        ^
      |                        |
      |                        int
./CPP_159.cpp:67:23: error: too few arguments to function ‘void eat(std::vector<int>*, int, int, int)’
   67 |     assert (issame(eat(4, 8, 9) , {12, 1}));
      |                    ~~~^~~~~~~~~
./CPP_159.cpp:7:6: note: declared here
    7 | void eat(vector<int>* v, int a, int b, int c) {
      |      ^~~
./CPP_159.cpp:68:24: error: invalid conversion from ‘int’ to ‘std::vector<int>*’ [-fpermissive]
   68 |     assert (issame(eat(1, 10, 10) , {11, 0}));
      |                        ^
      |                        |
      |                        int
./CPP_159.cpp:68:23: error: too few arguments to function ‘void eat(std::vector<int>*, int, int, int)’
   68 |     assert (issame(eat(1, 10, 10) , {11, 0}));
      |                    ~~~^~~~~~~~~~~
./CPP_159.cpp:7:6: note: declared here
    7 | void eat(vector<int>* v, int a, int b, int c) {
      |      ^~~
./CPP_159.cpp:69:24: error: invalid conversion from ‘int’ to ‘std::vector<int>*’ [-fpermissive]
   69 |     assert (issame(eat(2, 11, 5) , {7, 0}));
      |                        ^
      |                        |
      |                        int
./CPP_159.cpp:69:23: error: too few arguments to function ‘void eat(std::vector<int>*, int, int, int)’
   69 |     assert (issame(eat(2, 11, 5) , {7, 0}));
      |                    ~~~^~~~~~~~~~
./CPP_159.cpp:7:6: note: declared here
    7 | void eat(vector<int>* v, int a, int b, int c) {
      |      ^~~
./CPP_159.cpp:71:24: error: invalid conversion from ‘int’ to ‘std::vector<int>*’ [-fpermissive]
   71 |     assert (issame(eat(4, 5, 7) , {9, 2}));
      |                        ^
      |                        |
      |                        int
./CPP_159.cpp:71:23: error: too few arguments to function ‘void eat(std::vector<int>*, int, int, int)’
   71 |     assert (issame(eat(4, 5, 7) , {9, 2}));
      |                    ~~~^~~~~~~~~
./CPP_159.cpp:7:6: note: declared here
    7 | void eat(vector<int>* v, int a, int b, int c) {
      |      ^~~
./CPP_159.cpp:72:24: error: invalid conversion from ‘int’ to ‘std::vector<int>*’ [-fpermissive]
   72 |     assert (issame(eat(4, 5, 1) , {5, 0}));
      |                        ^
      |                        |
      |                        int
./CPP_159.cpp:72:23: error: too few arguments to function ‘void eat(std::vector<int>*, int, int, int)’
   72 |     assert (issame(eat(4, 5, 1) , {5, 0}));
      |                    ~~~^~~~~~~~~
./CPP_159.cpp:7:6: note: declared here
    7 | void eat(vector<int>* v, int a, int b, int c) {
      |      ^~~


CPP_57.cpp: Compilation Failed
Error: In file included from ./CPP_57.cpp:39:
./CPP_57.cpp: In function ‘int main()’:
./CPP_57.cpp:41:13: error: ‘monotonic’ was not declared in this scope; did you mean ‘monotonicSt’?
   41 |     assert (monotonic({1, 2, 4, 10}) == true);
      |             ^~~~~~~~~


CPP_64.cpp: Execution Failed
Error: CPP_64: ./CPP_64.cpp:31: int main(): Assertion `vowels_count("key") == 2' failed.
Aborted (core dumped)


CPP_36.cpp: Execution Failed
Error: CPP_36: ./CPP_36.cpp:25: int main(): Assertion `fizz_buzz(78) == 2' failed.
Aborted (core dumped)


CPP_134.cpp: Execution Failed
Error: CPP_134: ./CPP_134.cpp:37: int main(): Assertion `check_if_last_char_is_a_letter("apple") == false' failed.
Aborted (core dumped)


CPP_92.cpp: Execution Failed
Error: CPP_92: ./CPP_92.cpp:21: int main(): Assertion `any_int(2.5, 2, 3)==false' failed.
Aborted (core dumped)


CPP_163.cpp: Compilation Failed
Error: In file included from ./CPP_163.cpp:37:
./CPP_163.cpp: In function ‘int main()’:
./CPP_163.cpp:47:38: error: invalid initialization of non-const reference of type ‘std::vector<int>&’ from an rvalue of type ‘int’
   47 |     assert (issame(generate_integers(2, 10) , {2, 4, 6, 8}));
      |                                      ^
./CPP_163.cpp:6:37: note: in passing argument 1 of ‘void generate_integers(std::vector<int>&, int, int)’
    6 | void generate_integers(vector<int>& vec, int start, int end) {
      |                        ~~~~~~~~~~~~~^~~
./CPP_163.cpp:48:38: error: invalid initialization of non-const reference of type ‘std::vector<int>&’ from an rvalue of type ‘int’
   48 |     assert (issame(generate_integers(10, 2) , {2, 4, 6, 8}));
      |                                      ^~
./CPP_163.cpp:6:37: note: in passing argument 1 of ‘void generate_integers(std::vector<int>&, int, int)’
    6 | void generate_integers(vector<int>& vec, int start, int end) {
      |                        ~~~~~~~~~~~~~^~~
./CPP_163.cpp:49:38: error: invalid initialization of non-const reference of type ‘std::vector<int>&’ from an rvalue of type ‘int’
   49 |     assert (issame(generate_integers(132, 2) , {2, 4, 6, 8}));
      |                                      ^~~
./CPP_163.cpp:6:37: note: in passing argument 1 of ‘void generate_integers(std::vector<int>&, int, int)’
    6 | void generate_integers(vector<int>& vec, int start, int end) {
      |                        ~~~~~~~~~~~~~^~~
./CPP_163.cpp:50:38: error: invalid initialization of non-const reference of type ‘std::vector<int>&’ from an rvalue of type ‘int’
   50 |     assert (issame(generate_integers(17,89) , {}));
      |                                      ^~
./CPP_163.cpp:6:37: note: in passing argument 1 of ‘void generate_integers(std::vector<int>&, int, int)’
    6 | void generate_integers(vector<int>& vec, int start, int end) {
      |                        ~~~~~~~~~~~~~^~~


CPP_135.cpp: Compilation Failed
Error: In file included from ./CPP_135.cpp:45:
./CPP_135.cpp: In function ‘int main()’:
./CPP_135.cpp:47:24: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   47 |     assert (can_arrange({1,2,4,3,5})==3);
      |             ~~~~~~~~~~~^~~~~~~~~~~~~
In file included from /usr/include/c++/13/vector:66,
                 from ./CPP_135.cpp:1:
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_135.cpp:4:30: note:   initializing argument 1 of ‘int can_arrange(std::vector<int>&)’
    4 | int can_arrange(vector<int>& vec) {
      |                 ~~~~~~~~~~~~~^~~
./CPP_135.cpp:48:24: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   48 |     assert (can_arrange({1,2,4,5})==-1);
      |             ~~~~~~~~~~~^~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_135.cpp:4:30: note:   initializing argument 1 of ‘int can_arrange(std::vector<int>&)’
    4 | int can_arrange(vector<int>& vec) {
      |                 ~~~~~~~~~~~~~^~~
./CPP_135.cpp:49:24: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   49 |     assert (can_arrange({1,4,2,5,6,7,8,9,10})==2);
      |             ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_135.cpp:4:30: note:   initializing argument 1 of ‘int can_arrange(std::vector<int>&)’
    4 | int can_arrange(vector<int>& vec) {
      |                 ~~~~~~~~~~~~~^~~
./CPP_135.cpp:50:24: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   50 |     assert (can_arrange({4,8,5,7,3})==4);
      |             ~~~~~~~~~~~^~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_135.cpp:4:30: note:   initializing argument 1 of ‘int can_arrange(std::vector<int>&)’
    4 | int can_arrange(vector<int>& vec) {
      |                 ~~~~~~~~~~~~~^~~
./CPP_135.cpp:51:24: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   51 |     assert (can_arrange({})==-1);
      |             ~~~~~~~~~~~^~~~
/usr/include/c++/13/bits/stl_vector.h:531:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = int; _Alloc = std::allocator<int>]’
  531 |       vector() = default;
      |       ^~~~~~
./CPP_135.cpp:4:30: note:   initializing argument 1 of ‘int can_arrange(std::vector<int>&)’
    4 | int can_arrange(vector<int>& vec) {
      |                 ~~~~~~~~~~~~~^~~


CPP_132.cpp: Execution Failed
Error: CPP_132: ./CPP_132.cpp:37: int main(): Assertion `is_nested("[]]]]]]][[[[[]") == false' failed.
Aborted (core dumped)


CPP_66.cpp: Execution Failed
Error: CPP_66: ./CPP_66.cpp:17: int main(): Assertion `digitSum("abAB") == 131' failed.
Aborted (core dumped)


CPP_46.cpp: Compilation Failed
Error: ./CPP_46.cpp:34:5: error: redefinition of ‘int main()’
   34 | int main(){
      |     ^~~~
./CPP_46.cpp:27:5: note: ‘int main()’ previously defined here
   27 | int main() {
      |     ^~~~
In file included from ./CPP_46.cpp:33:
./CPP_46.cpp: In function ‘int main()’:
./CPP_46.cpp:35:13: error: ‘fib4’ was not declared in this scope; did you mean ‘fib’?
   35 |     assert (fib4(5) == 4);
      |             ^~~~


CPP_53.cpp: Compilation Failed
Error: ./CPP_53.cpp: In function ‘int main()’:
./CPP_53.cpp:15:15: error: ‘rand’ was not declared in this scope
   15 |         int x=rand()%1000;
      |               ^~~~


CPP_55.cpp: Compilation Failed
Error: In file included from ./CPP_55.cpp:22:
./CPP_55.cpp: In function ‘int main()’:
./CPP_55.cpp:24:13: error: ‘fib’ was not declared in this scope; did you mean ‘fibi’?
   24 |     assert (fib(10) == 55);
      |             ^~~


CPP_2.cpp: Compilation Failed
Error: In file included from ./CPP_2.cpp:7:
./CPP_2.cpp: In function ‘int main()’:
./CPP_2.cpp:10:10: error: ‘abs’ was not declared in this scope
   10 |  assert (abs(truncate_number(1.33) - 0.33) < 1e-4);
      |          ^~~


CPP_75.cpp: Compilation Failed
Error: ./CPP_75.cpp:2:101: warning: character constant too long for its type
    2 | Okay, so I have this LLVM IR code, and I need to decompile it back into C or C++ source code. Hmm, I'm a bit rusty on my LLVM IR, but I'll give it a shot. Let me start by looking at the code provided.
      |                                                                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:4:24: error: stray ‘@’ in program
    4 | The function is called @_Z17is_multiply_primei, which I think is a mangled C++ name. If I demangle that, it should give me a human-readable name. Let me try: "is_multiply_primei" – okay, so it's a function that probably checks if a number is a multiply prime or something like that.
      |                        ^
./CPP_75.cpp:4:180: error: extended character – is not valid in an identifier
    4 | The function is called @_Z17is_multiply_primei, which I think is a mangled C++ name. If I demangle that, it should give me a human-readable name. Let me try: "is_multiply_primei" – okay, so it's a function that probably checks if a number is a multiply prime or something like that.
      |                                                                                                                                                                                    ^
./CPP_75.cpp:4:193: warning: missing terminating ' character
    4 | The function is called @_Z17is_multiply_primei, which I think is a mangled C++ name. If I demangle that, it should give me a human-readable name. Let me try: "is_multiply_primei" – okay, so it's a function that probably checks if a number is a multiply prime or something like that.
      |                                                                                                                                                                                                 ^
./CPP_75.cpp:4:193: error: missing terminating ' character
    4 | The function is called @_Z17is_multiply_primei, which I think is a mangled C++ name. If I demangle that, it should give me a human-readable name. Let me try: "is_multiply_primei" – okay, so it's a function that probably checks if a number is a multiply prime or something like that.
      |                                                                                                                                                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:6:38: warning: missing terminating ' character
    6 | Looking at the function signature, it's a boolean function (returns i1) that takes an i32 parameter. So the function returns a bool and takes an integer.
      |                                      ^
./CPP_75.cpp:6:38: error: missing terminating ' character
    6 | Looking at the function signature, it's a boolean function (returns i1) that takes an i32 parameter. So the function returns a bool and takes an integer.
      |                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:12:239: warning: missing terminating ' character
   12 | Label 11 seems to handle the case where the input is less than 4. It uses a phi node to get %12, which is 0 or %25 from label 23. Then it checks if %12 is equal to 2. If yes, it returns true; otherwise, I guess it returns false, but I don't see a direct ret here. Hmm, maybe the other paths handle that.
      |                                                                                                                                                                                                                                               ^
./CPP_75.cpp:12:239: error: missing terminating ' character
   12 | Label 11 seems to handle the case where the input is less than 4. It uses a phi node to get %12, which is 0 or %25 from label 23. Then it checks if %12 is equal to 2. If yes, it returns true; otherwise, I guess it returns false, but I don't see a direct ret here. Hmm, maybe the other paths handle that.
      |                                                                                                                                                                                                                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:20:206: warning: missing terminating ' character
   20 | Putting this all together, it seems like the function is checking if a number is a "multiply prime." From what I remember, a multiply prime is a number where all its prime factors are unique, or perhaps it's a number that can be expressed as the product of primes in a certain way.
      |                                                                                                                                                                                                              ^
./CPP_75.cpp:20:206: error: missing terminating ' character
   20 | Putting this all together, it seems like the function is checking if a number is a "multiply prime." From what I remember, a multiply prime is a number where all its prime factors are unique, or perhaps it's a number that can be expressed as the product of primes in a certain way.
      |                                                                                                                                                                                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:28:58: warning: character constant too long for its type
   28 | 1. If n < 4, handle specially. For n=0,1,2,3, check if it's 2, which is a prime. Wait, but the function may return whether it's a multiply prime, which might not include 1. Hmm, maybe the initial check returns true only for 2.
      |                                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:30:166: warning: missing terminating ' character
   30 | 2. For n >=4, start checking from 2 upwards. For each possible divisor d starting at 2, check if d squared divides n. If d squared divides n, return false because it's not square-free. If d exceeds sqrt(n), then return true.
      |                                                                                                                                                                      ^
./CPP_75.cpp:30:166: error: missing terminating ' character
   30 | 2. For n >=4, start checking from 2 upwards. For each possible divisor d starting at 2, check if d squared divides n. If d squared divides n, return false because it's not square-free. If d exceeds sqrt(n), then return true.
      |                                                                                                                                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:34:26: warning: missing terminating ' character
   34 | Alternatively, perhaps it's checking if any divisor d of n has d squared dividing n.
      |                          ^
./CPP_75.cpp:34:26: error: missing terminating ' character
   34 | Alternatively, perhaps it's checking if any divisor d of n has d squared dividing n.
      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:46:252: warning: missing terminating ' character
   46 | Wait, looking back at the initial code, for n <4, it returns whether the number is 2. Because in label 11, it checks if %12 is 2. So, for n=0,1,2,3, it returns true only if n is 2. That suggests that the function is checking for primes, but that doesn't fit with the square-free idea.
      |                                                                                                                                                                                                                                                            ^
./CPP_75.cpp:46:252: error: missing terminating ' character
   46 | Wait, looking back at the initial code, for n <4, it returns whether the number is 2. Because in label 11, it checks if %12 is 2. So, for n=0,1,2,3, it returns true only if n is 2. That suggests that the function is checking for primes, but that doesn't fit with the square-free idea.
      |                                                                                                                                                                                                                                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:48:34: warning: missing terminating ' character
   48 | Wait, maybe I was wrong. Maybe it's checking if the number is a prime, but the function name suggests "multiply_prime," which is unclear.
      |                                  ^
./CPP_75.cpp:48:34: error: missing terminating ' character
   48 | Wait, maybe I was wrong. Maybe it's checking if the number is a prime, but the function name suggests "multiply_prime," which is unclear.
      |                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:50:26: warning: missing terminating ' character
   50 | Alternatively, perhaps it's checking if the number is square-free, but for n <4, only 2 is considered, which is a square-free prime.
      |                          ^
./CPP_75.cpp:50:26: error: missing terminating ' character
   50 | Alternatively, perhaps it's checking if the number is square-free, but for n <4, only 2 is considered, which is a square-free prime.
      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:54:73: warning: missing terminating ' character
   54 | The initial check is if n <4. If so, branch to label 11. In label 11, it's using a phi node for %12, which is 0 or %25 from label 23. Then it checks if %12 is 2, and returns true if so.
      |                                                                         ^
./CPP_75.cpp:54:73: error: missing terminating ' character
   54 | The initial check is if n <4. If so, branch to label 11. In label 11, it's using a phi node for %12, which is 0 or %25 from label 23. Then it checks if %12 is 2, and returns true if so.
      |                                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:66:69: warning: character constant too long for its type
   66 | So for n=4, the function returns false, which would make sense if it's checking for primes, but 4 is not prime. Alternatively, if it's checking for square-free, 4 is not square-free, so it returns false.
      |                                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:68:43: warning: character constant too long for its type
   68 | Wait, so n=4 would return false whether it's checking for primes or square-free. Let's try n=6.
      |                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:72:52: error: extended character ≠ is not valid in an identifier
   72 | In label14, %15=0, %16=6. %17=3, %18=1. %19=3 mod2=1≠0, so %22=false, go to label23.
      |                                                    ^
./CPP_75.cpp:76:20: error: extended character ≠ is not valid in an identifier
   76 | In label11, %12=1. 1≠2, so return false. But 6 is square-free (factors 2 and 3), so the function should return true. Hmm, this contradicts. So perhaps the function isn't checking for square-free.
      |                    ^
./CPP_75.cpp:76:168: warning: missing terminating ' character
   76 | In label11, %12=1. 1≠2, so return false. But 6 is square-free (factors 2 and 3), so the function should return true. Hmm, this contradicts. So perhaps the function isn't checking for square-free.
      |                                                                                                                                                                        ^
./CPP_75.cpp:76:168: error: missing terminating ' character
   76 | In label11, %12=1. 1≠2, so return false. But 6 is square-free (factors 2 and 3), so the function should return true. Hmm, this contradicts. So perhaps the function isn't checking for square-free.
      |                                                                                                                                                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:80:51: error: extended character ≠ is not valid in an identifier
   80 | Wait, in label14 for n=6, after %17=3, %19=3 mod2=1≠0, so %22 is false, so it goes to label23.
      |                                                   ^
./CPP_75.cpp:84:149: warning: missing terminating ' character
   84 | In label11, %12 is 1, which is not equal to 2, so ret 0 (false). But 6 is square-free, so the function returns false, which would be incorrect if it's supposed to check square-free.
      |                                                                                                                                                     ^
./CPP_75.cpp:84:149: error: missing terminating ' character
   84 | In label11, %12 is 1, which is not equal to 2, so ret 0 (false). But 6 is square-free, so the function returns false, which would be incorrect if it's supposed to check square-free.
      |                                                                                                                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:86:100: warning: missing terminating ' character
   86 | Wait, that suggests that the function is not correctly checking square-free. Alternatively, maybe I'm misunderstanding the code.
      |                                                                                                    ^
./CPP_75.cpp:86:100: error: missing terminating ' character
   86 | Wait, that suggests that the function is not correctly checking square-free. Alternatively, maybe I'm misunderstanding the code.
      |                                                                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:88:87: warning: character constant too long for its type
   88 | Alternatively, perhaps the function is checking for square factors greater than 1. Let's see: for n=6, it's 2*3. No square factors, so it should return true. But according to the code, it returns false. So perhaps the function is not checking for square-free.
      |                                                                                       ^~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:90:75: warning: character constant too long for its type
   90 | Alternatively, maybe the function is checking if n is a prime. For n=6, it's not prime, so returns false. For n=5, let's see.
      |                                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:92:39: error: extended character ≠ is not valid in an identifier
   92 | n=5: label3, %4=2, %5=0, %6=5. 5 mod2=1≠0, so go to label23.
      |                                       ^
./CPP_75.cpp:96:101: warning: missing terminating ' character
   96 | In label11, %12=0, which is not 2, so return false. But 5 is prime, so should return true. Hmm, that's a problem.
      |                                                                                                     ^
./CPP_75.cpp:96:101: error: missing terminating ' character
   96 | In label11, %12=0, which is not 2, so return false. But 5 is prime, so should return true. Hmm, that's a problem.
      |                                                                                                     ^~~~~~~~~~~~~
./CPP_75.cpp:98:16: warning: character constant too long for its type
   98 | Wait, perhaps I'm misunderstanding the code. Maybe the initial return is for when n is 2, but for primes larger than 2, it's not returning true.
      |                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:100:16: warning: missing terminating ' character
  100 | Wait, perhaps I'm missing something in the code. Let me look again.
      |                ^
./CPP_75.cpp:100:16: error: missing terminating ' character
  100 | Wait, perhaps I'm missing something in the code. Let me look again.
      |                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:104:52: error: extended character ≠ is not valid in an identifier
  104 | Next iteration in label3: %4=3, %5=0, %6=5. 5 mod3=2≠0, so go to label23.
      |                                                    ^
./CPP_75.cpp:108:60: warning: missing terminating ' character
  108 | In label11, %12=0, so return false. But 5 is prime, so that's incorrect.
      |                                                            ^
./CPP_75.cpp:108:60: error: missing terminating ' character
  108 | In label11, %12=0, so return false. But 5 is prime, so that's incorrect.
      |                                                            ^~~~~~~~~~~~~
./CPP_75.cpp:112:122: warning: missing terminating ' character
  112 | Wait, maybe the function is checking if n is a square of a prime. For n=4 (2^2), it returns false, but for n=9 (3^2), let's see.
      |                                                                                                                          ^
./CPP_75.cpp:112:122: error: missing terminating ' character
  112 | Wait, maybe the function is checking if n is a square of a prime. For n=4 (2^2), it returns false, but for n=9 (3^2), let's see.
      |                                                                                                                          ^~~~~~~
./CPP_75.cpp:114:39: error: extended character ≠ is not valid in an identifier
  114 | n=9: label3, %4=2, %5=0, %6=9. 9 mod2=1≠0, so go to label23.
      |                                       ^
./CPP_75.cpp:124:17: error: extended character ≠ is not valid in an identifier
  124 | In label11, %12=1≠2, return false. But 9 is 3 squared, so if the function is checking for square factors, it should return false, which it does. But for 6, it also returns false, which is wrong.
      |                 ^
./CPP_75.cpp:128:75: warning: missing terminating ' character
  128 | But for n=4=2^2, it returns false, so maybe not. Alternatively, perhaps it's checking if the number is a product of distinct primes, i.e., square-free and not prime.
      |                                                                           ^
./CPP_75.cpp:128:75: error: missing terminating ' character
  128 | But for n=4=2^2, it returns false, so maybe not. Alternatively, perhaps it's checking if the number is a product of distinct primes, i.e., square-free and not prime.
      |                                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:130:8: warning: missing terminating ' character
  130 | Wait, I'm getting confused. Let me try to think of what the code is doing step by step.
      |        ^
./CPP_75.cpp:130:8: error: missing terminating ' character
  130 | Wait, I'm getting confused. Let me try to think of what the code is doing step by step.
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:140:7: warning: missing terminating ' character
  140 | So, it's checking for consecutive divisions by d. If after dividing by d once, the quotient can be divided by d again, it continues; else, it moves on.
      |       ^
./CPP_75.cpp:140:7: error: missing terminating ' character
  140 | So, it's checking for consecutive divisions by d. If after dividing by d once, the quotient can be divided by d again, it continues; else, it moves on.
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:142:17: warning: character constant too long for its type
  142 | Wait, perhaps it's factoring n into primes, and checking if any prime occurs more than once. So, if n is divisible by d, and then the quotient is also divisible by d, then d^2 divides n, so it's not square-free.
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:150:252: warning: missing terminating ' character
  150 | But earlier, for n=6, the function returns false, which would be correct because 6 is square-free (factors 2 and 3, no squares). Wait, no, 6 is square-free, so the function should return true. But according to the code, for n=6, it returns false. That's a problem.
      |                                                                                                                                                                                                                                                            ^
./CPP_75.cpp:150:252: error: missing terminating ' character
  150 | But earlier, for n=6, the function returns false, which would be correct because 6 is square-free (factors 2 and 3, no squares). Wait, no, 6 is square-free, so the function should return true. But according to the code, for n=6, it returns false. That's a problem.
      |                                                                                                                                                                                                                                                            ^~~~~~~~~~~~~
./CPP_75.cpp:162:12: error: extended character ≠ is not valid in an identifier
  162 | %19=3 mod2=1≠0, so %22=false, go to label23.
      |            ^
./CPP_75.cpp:168:146: warning: missing terminating ' character
  168 | But 6 is square-free, so the function should return true. This suggests that the code is not correctly handling square-free numbers, or perhaps I'm misunderstanding the code.
      |                                                                                                                                                  ^
./CPP_75.cpp:168:146: error: missing terminating ' character
  168 | But 6 is square-free, so the function should return true. This suggests that the code is not correctly handling square-free numbers, or perhaps I'm misunderstanding the code.
      |                                                                                                                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:170:108: warning: missing terminating ' character
  170 | Alternatively, perhaps the function is checking if n is a prime, but for n=2, it returns true, for n=3, let's see.
      |                                                                                                            ^
./CPP_75.cpp:170:108: error: missing terminating ' character
  170 | Alternatively, perhaps the function is checking if n is a prime, but for n=2, it returns true, for n=3, let's see.
      |                                                                                                            ^~~~~~~
./CPP_75.cpp:174:11: error: extended character ≠ is not valid in an identifier
  174 | %7=3 mod2=1≠0, so go to label23.
      |           ^
./CPP_75.cpp:178:17: error: extended character ≠ is not valid in an identifier
  178 | In label11: %12=0≠2, so return false. But 3 is prime, which should return true. So the function is not correctly identifying primes either.
      |                 ^
./CPP_75.cpp:190:51: error: extended character ≠ is not valid in an identifier
  190 | Wait, in label14 for n=6, after %17=3, %19=3 mod2=1≠0, so %22=false, so it goes to label23.
      |                                                   ^
./CPP_75.cpp:202:106: warning: missing terminating ' character
  202 | Alternatively, perhaps the function is supposed to return whether n is a power of a prime, but that doesn't fit the initial condition.
      |                                                                                                          ^
./CPP_75.cpp:202:106: error: missing terminating ' character
  202 | Alternatively, perhaps the function is supposed to return whether n is a power of a prime, but that doesn't fit the initial condition.
      |                                                                                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:204:2: warning: character constant too long for its type
  204 | I'm getting stuck here. Maybe I should try to write the C++ code that matches the IR, regardless of what it's supposed to do, and then see.
      |  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:235:21: warning: missing terminating ' character
  235 | Wait, no, that doesn't quite fit. Alternatively, perhaps
      |                     ^
./CPP_75.cpp:235:21: error: missing terminating ' character
  235 | Wait, no, that doesn't quite fit. Alternatively, perhaps
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_75.cpp:1:1: error: expected unqualified-id before ‘<’ token
    1 | <think>
      | ^
./CPP_75.cpp:10:123: error: ‘otherwise’ does not name a type
   10 | The function starts with an icmp instruction checking if %0 (the input) is less than 4. If true, it branches to label 11; otherwise, it goes to label 3.
      |                                                                                                                           ^~~~~~~~~
./CPP_75.cpp:12:193: error: ‘otherwise’ does not name a type
   12 | Label 11 seems to handle the case where the input is less than 4. It uses a phi node to get %12, which is 0 or %25 from label 23. Then it checks if %12 is equal to 2. If yes, it returns true; otherwise, I guess it returns false, but I don't see a direct ret here. Hmm, maybe the other paths handle that.
      |                                                                                                                                                                                                 ^~~~~~~~~
./CPP_75.cpp:14:250: error: expected unqualified-id before ‘else’
   14 | Moving to label 3, there are phi nodes for %4, %5, %6. It looks like some loop variables. Then it calculates %7 as the remainder of %6 divided by %4. Then it checks if %7 is 0 and if %6 is greater than %4. If both are true, it branches to label 14; else, it goes to 23.
      |                                                                                                                                                                                                                                                          ^~~~
./CPP_75.cpp:16:208: error: ‘otherwise’ does not name a type
   16 | Label 14 seems to be another loop. It has phi nodes for %15 and %16. Then it divides %16 by %4, increments %15, and checks if the remainder is 0 and if the quotient is greater than %4. If so, it loops back; otherwise, it goes to label 23.
      |                                                                                                                                                                                                                ^~~~~~~~~
./CPP_75.cpp:18:187: error: expected unqualified-id before ‘else’
   18 | Label 23 updates some variables using phi nodes again, increments %4, calculates %26 as %4+1, then %27 as %26 squared. It checks if %27 is greater than %24. If yes, it goes to label 11; else, back to label 3.
      |                                                                                                                                                                                           ^~~~
./CPP_75.cpp:24:177: error: ‘otherwise’ does not name a type
   24 | Looking at the code, the function seems to iterate through possible divisors, checking if any divisor squared divides the number. If it finds such a divisor, it returns false; otherwise, it returns true. That would align with checking for square-free numbers.
      |                                                                                                                                                                                 ^~~~~~~~~
./CPP_75.cpp:32:223: error: expected unqualified-id before ‘else’
   32 | Wait, but the code in label 3 starts with %4 as 2, and %5 as 0, %6 as %0 (n). Then it checks if n mod d is 0 and if n > d. If so, it goes to label 14, which seems to check if n/d is divisible by d again. If yes, it loops; else, it continues.
      |                                                                                                                                                                                                                               ^~~~
./CPP_75.cpp:182:187: error: expected unqualified-id before ‘else’
  182 | The function seems to have a loop that starts with d=2, and for each d, it checks if d divides n. If it does, it then checks if the quotient is also divisible by d. If so, it continues; else, it proceeds.
      |                                                                                                                                                                                           ^~~~
./CPP_75.cpp:212:1: error: expected unqualified-id before ‘else’
  212 | else, it enters a loop with d starting at 2.
      | ^~~~
./CPP_75.cpp:235:1: error: ‘Wait’ does not name a type
  235 | Wait, no, that doesn't quite fit. Alternatively, perhaps
      | ^~~~
In file included from ./CPP_75.cpp:237:
./CPP_75.cpp: In function ‘int main()’:
./CPP_75.cpp:239:13: error: ‘is_multiply_prime’ was not declared in this scope
  239 |     assert (is_multiply_prime(5) == false);
      |             ^~~~~~~~~~~~~~~~~
./CPP_75.cpp:239:5: error: ‘__assert_fail’ was not declared in this scope
  239 |     assert (is_multiply_prime(5) == false);
      |     ^~~~~~


CPP_128.cpp: Compilation Failed
Error: In file included from ./CPP_128.cpp:31:
./CPP_128.cpp: In function ‘int main()’:
./CPP_128.cpp:33:23: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   33 |     assert (prod_signs({1, 2, 2, -4}) == -9);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~
In file included from /usr/include/c++/13/vector:66,
                 from ./CPP_128.cpp:1:
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_128.cpp:4:34: note:   initializing argument 1 of ‘int prod_signs(std::vector<int>&)’
    4 | int prod_signs(std::vector<int>& vec) {
      |                ~~~~~~~~~~~~~~~~~~^~~
./CPP_128.cpp:34:23: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   34 |     assert (prod_signs({0, 1}) == 0);
      |             ~~~~~~~~~~^~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_128.cpp:4:34: note:   initializing argument 1 of ‘int prod_signs(std::vector<int>&)’
    4 | int prod_signs(std::vector<int>& vec) {
      |                ~~~~~~~~~~~~~~~~~~^~~
./CPP_128.cpp:35:23: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   35 |     assert (prod_signs({1, 1, 1, 2, 3, -1, 1}) == -10);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_128.cpp:4:34: note:   initializing argument 1 of ‘int prod_signs(std::vector<int>&)’
    4 | int prod_signs(std::vector<int>& vec) {
      |                ~~~~~~~~~~~~~~~~~~^~~
./CPP_128.cpp:36:23: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   36 |     assert (prod_signs({}) == -32768);
      |             ~~~~~~~~~~^~~~
/usr/include/c++/13/bits/stl_vector.h:531:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = int; _Alloc = std::allocator<int>]’
  531 |       vector() = default;
      |       ^~~~~~
./CPP_128.cpp:4:34: note:   initializing argument 1 of ‘int prod_signs(std::vector<int>&)’
    4 | int prod_signs(std::vector<int>& vec) {
      |                ~~~~~~~~~~~~~~~~~~^~~
./CPP_128.cpp:37:23: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   37 |     assert (prod_signs({2, 4,1, 2, -1, -1, 9}) == 20);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_128.cpp:4:34: note:   initializing argument 1 of ‘int prod_signs(std::vector<int>&)’
    4 | int prod_signs(std::vector<int>& vec) {
      |                ~~~~~~~~~~~~~~~~~~^~~
./CPP_128.cpp:38:23: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   38 |     assert (prod_signs({-1, 1, -1, 1}) == 4);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_128.cpp:4:34: note:   initializing argument 1 of ‘int prod_signs(std::vector<int>&)’
    4 | int prod_signs(std::vector<int>& vec) {
      |                ~~~~~~~~~~~~~~~~~~^~~
./CPP_128.cpp:39:23: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   39 |     assert (prod_signs({-1, 1, 1, 1}) == -4);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_128.cpp:4:34: note:   initializing argument 1 of ‘int prod_signs(std::vector<int>&)’
    4 | int prod_signs(std::vector<int>& vec) {
      |                ~~~~~~~~~~~~~~~~~~^~~
./CPP_128.cpp:40:23: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   40 |     assert (prod_signs({-1, 1, 1, 0}) == 0);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_128.cpp:4:34: note:   initializing argument 1 of ‘int prod_signs(std::vector<int>&)’
    4 | int prod_signs(std::vector<int>& vec) {
      |                ~~~~~~~~~~~~~~~~~~^~~


CPP_62.cpp: Compilation Failed
Error: ./CPP_62.cpp: In constructor ‘DerivativeVector::DerivativeVector(const std::vector<float>&)’:
./CPP_62.cpp:19:20: error: no match for ‘operator[]’ (operand types are ‘DerivativeVector’ and ‘size_t’ {aka ‘long unsigned int’})
   19 |             (*this)[i] = input_vector[i] * static_cast<float>(i + 1);
      |                    ^
./CPP_62.cpp: In member function ‘size_t DerivativeVector::size() const’:
./CPP_62.cpp:30:53: warning: no return statement in function returning non-void [-Wreturn-type]
   30 |     size_t size() const { /* return current size */ }
      |                                                     ^
./CPP_62.cpp: In member function ‘size_t DerivativeVector::capacity() const’:
./CPP_62.cpp:31:61: warning: no return statement in function returning non-void [-Wreturn-type]
   31 |     size_t capacity() const { /* return current capacity */ }
      |                                                             ^
./CPP_62.cpp: At global scope:
./CPP_62.cpp:36:13: error: ‘vector’ was not declared in this scope
   36 | bool issame(vector<float> a,vector<float>b){
      |             ^~~~~~
./CPP_62.cpp:36:13: note: suggested alternatives:
In file included from /usr/include/c++/13/vector:66,
                 from ./CPP_62.cpp:1:
/usr/include/c++/13/bits/stl_vector.h:428:11: note:   ‘std::vector’
  428 |     class vector : protected _Vector_base<_Tp, _Alloc>
      |           ^~~~~~
/usr/include/c++/13/vector:86:13: note:   ‘std::pmr::vector’
   86 |       using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
      |             ^~~~~~
./CPP_62.cpp:36:20: error: expected primary-expression before ‘float’
   36 | bool issame(vector<float> a,vector<float>b){
      |                    ^~~~~
./CPP_62.cpp:36:29: error: ‘vector’ was not declared in this scope
   36 | bool issame(vector<float> a,vector<float>b){
      |                             ^~~~~~
./CPP_62.cpp:36:29: note: suggested alternatives:
/usr/include/c++/13/bits/stl_vector.h:428:11: note:   ‘std::vector’
  428 |     class vector : protected _Vector_base<_Tp, _Alloc>
      |           ^~~~~~
/usr/include/c++/13/vector:86:13: note:   ‘std::pmr::vector’
   86 |       using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
      |             ^~~~~~
./CPP_62.cpp:36:36: error: expected primary-expression before ‘float’
   36 | bool issame(vector<float> a,vector<float>b){
      |                                    ^~~~~
./CPP_62.cpp:36:43: error: expression list treated as compound expression in initializer [-fpermissive]
   36 | bool issame(vector<float> a,vector<float>b){
      |                                           ^
In file included from ./CPP_62.cpp:35:
./CPP_62.cpp: In function ‘int main()’:
./CPP_62.cpp:45:20: error: ‘derivative’ was not declared in this scope
   45 |     assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));
      |                    ^~~~~~~~~~
./CPP_62.cpp:45:19: error: ‘issame’ cannot be used as a function
   45 |     assert (issame(derivative({3, 1, 2, 4, 5}) , {1, 4, 12, 20}));
      |             ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_62.cpp:46:19: error: ‘issame’ cannot be used as a function
   46 |     assert (issame(derivative({1, 2, 3}) , {2, 6}));
      |             ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_62.cpp:47:19: error: ‘issame’ cannot be used as a function
   47 |     assert (issame(derivative({3, 2, 1}) , {2, 2}));
      |             ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_62.cpp:48:19: error: ‘issame’ cannot be used as a function
   48 |     assert (issame(derivative({3, 2, 1, 0, 4}) , {2, 2, 0, 16}));
      |             ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./CPP_62.cpp:49:19: error: ‘issame’ cannot be used as a function
   49 |     assert (issame(derivative({1}) , {}));
      |             ~~~~~~^~~~~~~~~~~~~~~~~~~~~~


CPP_45.cpp: Compilation Failed
Error: ./CPP_45.cpp:21:5: error: redefinition of ‘int main()’
   21 | int main(){
      |     ^~~~
./CPP_45.cpp:8:5: note: ‘int main()’ previously defined here
    8 | int main() {
      |     ^~~~


CPP_77.cpp: Compilation Failed
Error: In file included from ./CPP_77.cpp:19:
./CPP_77.cpp: In function ‘int main()’:
./CPP_77.cpp:21:13: error: ‘iscuber’ was not declared in this scope; did you mean ‘iscuberi’?
   21 |     assert (iscuber(1) == true);
      |             ^~~~~~~


CPP_76.cpp: Compilation Failed
Error: ./CPP_76.cpp:39:5: error: redefinition of ‘int main()’
   39 | int main(){
      |     ^~~~
./CPP_76.cpp:29:5: note: ‘int main()’ previously defined here
   29 | int main() {
      |     ^~~~


CPP_40.cpp: Execution Failed
Error: CPP_40: ./CPP_40.cpp:24: int main(): Assertion `triples_sum_to_zero({1, 3, -2, 1}) == true' failed.
Aborted (core dumped)


CPP_52.cpp: Compilation Failed
Error: ./CPP_52.cpp: In function ‘bool below_threshold(const std::vector<int>&, int)’:
./CPP_52.cpp:12:30: error: no matching function for call to ‘max(unsigned int, size_t)’
   12 |     size_t num_elements = max(1U, size / 4);
      |                           ~~~^~~~~~~~~~~~~~
In file included from /usr/include/c++/13/vector:62,
                 from ./CPP_52.cpp:1:
/usr/include/c++/13/bits/stl_algobase.h:257:5: note: candidate: ‘template<class _Tp> constexpr const _Tp& std::max(const _Tp&, const _Tp&)’
  257 |     max(const _Tp& __a, const _Tp& __b)
      |     ^~~
/usr/include/c++/13/bits/stl_algobase.h:257:5: note:   template argument deduction/substitution failed:
./CPP_52.cpp:12:30: note:   deduced conflicting types for parameter ‘const _Tp’ (‘unsigned int’ and ‘size_t’ {aka ‘long unsigned int’})
   12 |     size_t num_elements = max(1U, size / 4);
      |                           ~~~^~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_algobase.h:303:5: note: candidate: ‘template<class _Tp, class _Compare> constexpr const _Tp& std::max(const _Tp&, const _Tp&, _Compare)’
  303 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)
      |     ^~~
/usr/include/c++/13/bits/stl_algobase.h:303:5: note:   template argument deduction/substitution failed:
./CPP_52.cpp:12:30: note:   deduced conflicting types for parameter ‘const _Tp’ (‘unsigned int’ and ‘size_t’ {aka ‘long unsigned int’})
   12 |     size_t num_elements = max(1U, size / 4);
      |                           ~~~^~~~~~~~~~~~~~


CPP_8.cpp: Execution Failed
Error: CPP_8: ./CPP_8.cpp:48: int main(): Assertion `issame(sum_product({}) ,{0, 1})' failed.
Aborted (core dumped)


CPP_98.cpp: Execution Failed
Error: CPP_98: ./CPP_98.cpp:25: int main(): Assertion `count_upper("dBBE") == 0' failed.
Aborted (core dumped)


CPP_73.cpp: Execution Failed
Error: CPP_73: ./CPP_73.cpp:19: int main(): Assertion `smallest_change({1,2,3,5,4,7,9,6}) == 4' failed.
Aborted (core dumped)


CPP_39.cpp: Compilation Failed
Error: ./CPP_39.cpp:42:5: error: redefinition of ‘int main()’
   42 | int main(){
      |     ^~~~
./CPP_39.cpp:32:5: note: ‘int main()’ previously defined here
   32 | int main() {
      |     ^~~~
In file included from ./CPP_39.cpp:41:
./CPP_39.cpp: In function ‘int main()’:
./CPP_39.cpp:43:13: error: ‘prime_fib’ was not declared in this scope; did you mean ‘prime_fibi’?
   43 |     assert (prime_fib(1) == 2);
      |             ^~~~~~~~~


CPP_43.cpp: Execution Failed
Error: CPP_43: ./CPP_43.cpp:28: int main(): Assertion `pairs_sum_to_zero({2, 4, -5, 3, 5, 7}) == true' failed.
Aborted (core dumped)


CPP_91.cpp: Execution Failed
Error: CPP_91: ./CPP_91.cpp:74: int main(): Assertion `is_bored("Is the sky blue?") == 0' failed.
Aborted (core dumped)


CPP_49.cpp: Compilation Failed
Error: ./CPP_49.cpp:32:5: error: redefinition of ‘int main()’
   32 | int main(){
      |     ^~~~
./CPP_49.cpp:23:5: note: ‘int main()’ previously defined here
   23 | int main() {
      |     ^~~~
In file included from ./CPP_49.cpp:31:
./CPP_49.cpp: In function ‘int main()’:
./CPP_49.cpp:33:13: error: ‘modp’ was not declared in this scope; did you mean ‘mod_pi’?
   33 |     assert (modp(3, 5) == 3);
      |             ^~~~


CPP_150.cpp: Compilation Failed
Error: ./CPP_150.cpp:23:5: error: redefinition of ‘int main()’
   23 | int main(){
      |     ^~~~
./CPP_150.cpp:14:5: note: ‘int main()’ previously defined here
   14 | int main() {
      |     ^~~~


CPP_136.cpp: Execution Failed
Error: CPP_136: ./CPP_136.cpp:53: int main(): Assertion `issame(largest_smallest_integers({2, 4, 1, 3, 5, 7}) , {0, 1})' failed.
Aborted (core dumped)


CPP_9.cpp: Compilation Failed
Error: ./CPP_9.cpp:33:5: error: redefinition of ‘int main()’
   33 | int main(){
      |     ^~~~
./CPP_9.cpp:16:5: note: ‘int main()’ previously defined here
   16 | int main() {
      |     ^~~~
In file included from ./CPP_9.cpp:24:
./CPP_9.cpp: In function ‘int main()’:
./CPP_9.cpp:34:32: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   34 |      assert (issame(rolling_max({}),{}));
      |                     ~~~~~~~~~~~^~~~
In file included from /usr/include/c++/13/vector:66,
                 from ./CPP_9.cpp:1:
/usr/include/c++/13/bits/stl_vector.h:531:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector() [with _Tp = int; _Alloc = std::allocator<int>]’
  531 |       vector() = default;
      |       ^~~~~~
./CPP_9.cpp:6:31: note: in passing argument 1 of ‘void rolling_max(std::vector<int>&, const std::vector<int>&)’
    6 | void rolling_max(vector<int>& result, const vector<int>& input) {
      |                  ~~~~~~~~~~~~~^~~~~~
./CPP_9.cpp:35:31: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   35 |     assert (issame(rolling_max({1, 2, 3, 4}) , {1, 2, 3, 4}));
      |                    ~~~~~~~~~~~^~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_9.cpp:6:31: note: in passing argument 1 of ‘void rolling_max(std::vector<int>&, const std::vector<int>&)’
    6 | void rolling_max(vector<int>& result, const vector<int>& input) {
      |                  ~~~~~~~~~~~~~^~~~~~
./CPP_9.cpp:36:32: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   36 |      assert (issame(rolling_max({4, 3, 2, 1}),{4, 4, 4, 4}));
      |                     ~~~~~~~~~~~^~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_9.cpp:6:31: note: in passing argument 1 of ‘void rolling_max(std::vector<int>&, const std::vector<int>&)’
    6 | void rolling_max(vector<int>& result, const vector<int>& input) {
      |                  ~~~~~~~~~~~~~^~~~~~
./CPP_9.cpp:37:33: error: cannot bind non-const lvalue reference of type ‘std::vector<int>&’ to an rvalue of type ‘std::vector<int>’
   37 |       assert (issame(rolling_max({3, 2, 3, 100, 3}) ,{3, 3, 3, 100, 100}));
      |                      ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~
/usr/include/c++/13/bits/stl_vector.h:678:7: note:   after user-defined conversion: ‘std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = int; _Alloc = std::allocator<int>; allocator_type = std::allocator<int>]’
  678 |       vector(initializer_list<value_type> __l,
      |       ^~~~~~
./CPP_9.cpp:6:31: note: in passing argument 1 of ‘void rolling_max(std::vector<int>&, const std::vector<int>&)’
    6 | void rolling_max(vector<int>& result, const vector<int>& input) {
      |                  ~~~~~~~~~~~~~^~~~~~


CPP_127.cpp: Execution Failed
Error: CPP_127: ./CPP_127.cpp:29: int main(): Assertion `intersection({1, 2}, {2, 3}) == "NO"' failed.
Aborted (core dumped)


CPP_100.cpp: Compilation Failed
Error: ./CPP_100.cpp: In function ‘void make_a_pile_i(std::vector<int>&, int)’:
./CPP_100.cpp:8:24: error: ‘void std::vector<_Tp, _Alloc>::_M_realloc_insert(iterator, _Args&& ...) [with _Args = {int&}; _Tp = int; _Alloc = std::allocator<int>; iterator = std::vector<int>::iterator]’ is protected within this context
    8 |     v._M_realloc_insert(v.begin(), size);
      |     ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/13/vector:72,
                 from ./CPP_100.cpp:1:
/usr/include/c++/13/bits/vector.tcc:445:7: note: declared protected here
  445 |       vector<_Tp, _Alloc>::
      |       ^~~~~~~~~~~~~~~~~~~
./CPP_100.cpp:12:23: error: ‘class std::vector<int>’ has no member named ‘_M_data’; did you mean ‘data’?
   12 |         int* data = v._M_data();
      |                       ^~~~~~~
      |                       data
In file included from ./CPP_100.cpp:21:
./CPP_100.cpp: In function ‘int main()’:
./CPP_100.cpp:31:20: error: ‘make_a_pile’ was not declared in this scope; did you mean ‘make_a_pile_i’?
   31 |     assert (issame(make_a_pile(3) , {3, 5, 7}));
      |                    ^~~~~~~~~~~


CPP_24.cpp: Compilation Failed
Error: ./CPP_24.cpp:27:5: error: redefinition of ‘int main()’
   27 | int main(){
      |     ^~~~
./CPP_24.cpp:19:5: note: ‘int main()’ previously defined here
   19 | int main() {
      |     ^~~~


CPP_11.cpp: Compilation Failed
Error: In file included from ./CPP_11.cpp:21:
./CPP_11.cpp: In function ‘int main()’:
./CPP_11.cpp:23:24: error: cannot bind non-const lvalue reference of type ‘std::string&’ {aka ‘std::__cxx11::basic_string<char>&’} to an rvalue of type ‘std::string’ {aka ‘std::__cxx11::basic_string<char>’}
   23 |     assert (string_xor("111000", "101010") == "010010");
      |                        ^~~~~~~~
In file included from /usr/include/c++/13/string:54,
                 from ./CPP_11.cpp:1:
/usr/include/c++/13/bits/basic_string.h:641:7: note:   after user-defined conversion: ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with <template-parameter-2-1> = std::allocator<char>; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’
  641 |       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      |       ^~~~~~~~~~~~
./CPP_11.cpp:6:25: note: in passing argument 1 of ‘void string_xor(std::string&, const std::string&, const std::string&)’
    6 | void string_xor(string& result, const string& a, const string& b) {
      |                 ~~~~~~~~^~~~~~
./CPP_11.cpp:24:25: error: cannot bind non-const lvalue reference of type ‘std::string&’ {aka ‘std::__cxx11::basic_string<char>&’} to an rvalue of type ‘std::string’ {aka ‘std::__cxx11::basic_string<char>’}
   24 |      assert (string_xor("1", "1") == "0");
      |                         ^~~
/usr/include/c++/13/bits/basic_string.h:641:7: note:   after user-defined conversion: ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with <template-parameter-2-1> = std::allocator<char>; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’
  641 |       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      |       ^~~~~~~~~~~~
./CPP_11.cpp:6:25: note: in passing argument 1 of ‘void string_xor(std::string&, const std::string&, const std::string&)’
    6 | void string_xor(string& result, const string& a, const string& b) {
      |                 ~~~~~~~~^~~~~~
./CPP_11.cpp:25:24: error: cannot bind non-const lvalue reference of type ‘std::string&’ {aka ‘std::__cxx11::basic_string<char>&’} to an rvalue of type ‘std::string’ {aka ‘std::__cxx11::basic_string<char>’}
   25 |     assert (string_xor("0101", "0000") == "0101");
      |                        ^~~~~~
/usr/include/c++/13/bits/basic_string.h:641:7: note:   after user-defined conversion: ‘std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with <template-parameter-2-1> = std::allocator<char>; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]’
  641 |       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      |       ^~~~~~~~~~~~
./CPP_11.cpp:6:25: note: in passing argument 1 of ‘void string_xor(std::string&, const std::string&, const std::string&)’
    6 | void string_xor(string& result, const string& a, const string& b) {
      |                 ~~~~~~~~^~~~~~


CPP_96.cpp: Compilation Failed
Error: ./CPP_96.cpp: In function ‘std::vector<int> count_up_to(int)’:
./CPP_96.cpp:14:29: error: ‘class std::vector<int>’ has no member named ‘_Get_first’
   14 |     int* start_ptr = result._Get_first();
      |                             ^~~~~~~~~~
./CPP_96.cpp:15:27: error: ‘class std::vector<int>’ has no member named ‘_Get_last’
   15 |     int* end_ptr = result._Get_last();
      |                           ^~~~~~~~~
./CPP_96.cpp:16:27: error: ‘class std::vector<int>’ has no member named ‘_Get_end’
   16 |     int* cap_ptr = result._Get_end();
      |                           ^~~~~~~~


CPP_114.cpp: Compilation Failed
Error: ./CPP_114.cpp: In function ‘long long int minSubArraySum(const std::vector<long long int>&)’:
./CPP_114.cpp:7:34: error: invalid conversion from ‘const long long int*’ to ‘long long int*’ [-fpermissive]
    7 |     long long* dataPtr = arr.data();
      |                          ~~~~~~~~^~
      |                                  |
      |                                  const long long int*


CPP_68.cpp: Compilation Failed
Error: ./CPP_68.cpp: In function ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’:
./CPP_68.cpp:15:24: error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive]
   15 |     int* input_start = &*input->begin();
      |                        ^~~~~~~~~~~~~~~~
      |                        |
      |                        const int*
./CPP_68.cpp:16:22: error: invalid conversion from ‘const int*’ to ‘int*’ [-fpermissive]
   16 |     int* input_end = &*input->end();
      |                      ^~~~~~~~~~~~~~
      |                      |
      |                      const int*
./CPP_68.cpp:32:54: error: invalid type argument of unary ‘*’ (have ‘long long int’)
   32 |         *reinterpret_cast<long long*>(new_element) = *reinterpret_cast<long long>(current_element);
      |                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from ./CPP_68.cpp:46:
./CPP_68.cpp: In function ‘int main()’:
./CPP_68.cpp:56:25: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int, std::allocator<int> >*’
   56 |     assert (issame(pluck({4,2,3}) , {2, 1}));
      |                    ~~~~~^~~~~~~~~
      |                         |
      |                         <brace-enclosed initializer list>
./CPP_68.cpp:7:41: note:   initializing argument 1 of ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’
    7 | void pluck(vector<int, allocator<int>>* output, const vector<int, allocator<int>>* input) {
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_68.cpp:57:25: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int, std::allocator<int> >*’
   57 |     assert (issame(pluck({1,2,3}) , {2, 1}));
      |                    ~~~~~^~~~~~~~~
      |                         |
      |                         <brace-enclosed initializer list>
./CPP_68.cpp:7:41: note:   initializing argument 1 of ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’
    7 | void pluck(vector<int, allocator<int>>* output, const vector<int, allocator<int>>* input) {
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_68.cpp:58:25: error: too few arguments to function ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’
   58 |     assert (issame(pluck({}) , {}));
      |                    ~~~~~^~~~
./CPP_68.cpp:7:6: note: declared here
    7 | void pluck(vector<int, allocator<int>>* output, const vector<int, allocator<int>>* input) {
      |      ^~~~~
./CPP_68.cpp:59:25: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int, std::allocator<int> >*’
   59 |     assert (issame(pluck({5, 0, 3, 0, 4, 2}) , {0, 1}));
      |                    ~~~~~^~~~~~~~~~~~~~~~~~~~
      |                         |
      |                         <brace-enclosed initializer list>
./CPP_68.cpp:7:41: note:   initializing argument 1 of ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’
    7 | void pluck(vector<int, allocator<int>>* output, const vector<int, allocator<int>>* input) {
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_68.cpp:60:25: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int, std::allocator<int> >*’
   60 |     assert (issame(pluck({1, 2, 3, 0, 5, 3}) , {0, 3}));
      |                    ~~~~~^~~~~~~~~~~~~~~~~~~~
      |                         |
      |                         <brace-enclosed initializer list>
./CPP_68.cpp:7:41: note:   initializing argument 1 of ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’
    7 | void pluck(vector<int, allocator<int>>* output, const vector<int, allocator<int>>* input) {
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_68.cpp:61:25: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int, std::allocator<int> >*’
   61 |     assert (issame(pluck({5, 4, 8, 4 ,8}) , {4, 1}));
      |                    ~~~~~^~~~~~~~~~~~~~~~~
      |                         |
      |                         <brace-enclosed initializer list>
./CPP_68.cpp:7:41: note:   initializing argument 1 of ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’
    7 | void pluck(vector<int, allocator<int>>* output, const vector<int, allocator<int>>* input) {
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_68.cpp:62:25: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int, std::allocator<int> >*’
   62 |     assert (issame(pluck({7, 6, 7, 1}) , {6, 1}));
      |                    ~~~~~^~~~~~~~~~~~~~
      |                         |
      |                         <brace-enclosed initializer list>
./CPP_68.cpp:7:41: note:   initializing argument 1 of ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’
    7 | void pluck(vector<int, allocator<int>>* output, const vector<int, allocator<int>>* input) {
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~
./CPP_68.cpp:63:25: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int, std::allocator<int> >*’
   63 |     assert (issame(pluck({7, 9, 7, 1}) , {}));
      |                    ~~~~~^~~~~~~~~~~~~~
      |                         |
      |                         <brace-enclosed initializer list>
./CPP_68.cpp:7:41: note:   initializing argument 1 of ‘void pluck(std::vector<int, std::allocator<int> >*, const std::vector<int, std::allocator<int> >*)’
    7 | void pluck(vector<int, allocator<int>>* output, const vector<int, allocator<int>>* input) {
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~


CPP_59.cpp: Compilation Failed
Error: ./CPP_59.cpp:32:5: error: redefinition of ‘int main()’
   32 | int main(){
      |     ^~~~
./CPP_59.cpp:22:5: note: ‘int main()’ previously defined here
   22 | int main() {
      |     ^~~~


CPP_85.cpp: Compilation Failed
Error: ./CPP_85.cpp: In function ‘int add(std::vector<int>*)’:
./CPP_85.cpp:11:9: error: ‘__m128i’ was not declared in this scope
   11 |         __m128i vec_data;
      |         ^~~~~~~
./CPP_85.cpp:12:9: error: ‘vec_data’ was not declared in this scope
   12 |         vec_data = _mm_loadu_si128((__m128i *)data);
      |         ^~~~~~~~
./CPP_85.cpp:12:46: error: expected primary-expression before ‘)’ token
   12 |         vec_data = _mm_loadu_si128((__m128i *)data);
      |                                              ^
./CPP_85.cpp:12:20: error: ‘_mm_loadu_si128’ was not declared in this scope
   12 |         vec_data = _mm_loadu_si128((__m128i *)data);
      |                    ^~~~~~~~~~~~~~~
./CPP_85.cpp:14:16: error: expected ‘;’ before ‘mask’
   14 |         __m128i mask = _mm_and_si128(vec_data, _mm_set1_epi32(1));
      |                ^~~~~
      |                ;
./CPP_85.cpp:15:16: error: expected ‘;’ before ‘zeros’
   15 |         __m128i zeros = _mm_set1_epi32(0);
      |                ^~~~~~
      |                ;
./CPP_85.cpp:16:16: error: expected ‘;’ before ‘valid’
   16 |         __m128i valid = _mm_cmpeq_epi32(mask, zeros);
      |                ^~~~~~
      |                ;
./CPP_85.cpp:17:37: error: ‘valid’ was not declared in this scope
   17 |         vec_data = _mm_andnot_si128(valid, vec_data);
      |                                     ^~~~~
./CPP_85.cpp:17:20: error: ‘_mm_andnot_si128’ was not declared in this scope
   17 |         vec_data = _mm_andnot_si128(valid, vec_data);
      |                    ^~~~~~~~~~~~~~~~
./CPP_85.cpp:19:22: error: ‘_mm_reduce_add’ was not declared in this scope
   19 |         int result = _mm_reduce_add(vec_data);
      |                      ^~~~~~~~~~~~~~
In file included from ./CPP_85.cpp:36:
./CPP_85.cpp: In function ‘int main()’:
./CPP_85.cpp:38:16: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   38 |     assert (add({4, 88}) == 88);
      |             ~~~^~~~~~~~~
      |                |
      |                <brace-enclosed initializer list>
./CPP_85.cpp:4:22: note:   initializing argument 1 of ‘int add(std::vector<int>*)’
    4 | int add(vector<int> *vec) {
      |         ~~~~~~~~~~~~~^~~
./CPP_85.cpp:39:16: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   39 |     assert (add({4, 5, 6, 7, 2, 122}) == 122);
      |             ~~~^~~~~~~~~~~~~~~~~~~~~~
      |                |
      |                <brace-enclosed initializer list>
./CPP_85.cpp:4:22: note:   initializing argument 1 of ‘int add(std::vector<int>*)’
    4 | int add(vector<int> *vec) {
      |         ~~~~~~~~~~~~~^~~
./CPP_85.cpp:40:16: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   40 |     assert (add({4, 0, 6, 7}) == 0);
      |             ~~~^~~~~~~~~~~~~~
      |                |
      |                <brace-enclosed initializer list>
./CPP_85.cpp:4:22: note:   initializing argument 1 of ‘int add(std::vector<int>*)’
    4 | int add(vector<int> *vec) {
      |         ~~~~~~~~~~~~~^~~
./CPP_85.cpp:41:16: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   41 |     assert (add({4, 4, 6, 8}) == 12);
      |             ~~~^~~~~~~~~~~~~~
      |                |
      |                <brace-enclosed initializer list>
./CPP_85.cpp:4:22: note:   initializing argument 1 of ‘int add(std::vector<int>*)’
    4 | int add(vector<int> *vec) {
      |         ~~~~~~~~~~~~~^~~


CPP_108.cpp: Compilation Failed
Error: In file included from ./CPP_108.cpp:43:
./CPP_108.cpp: In function ‘int main()’:
./CPP_108.cpp:46:23: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   46 |     assert (count_nums({-1, -2, 0}) == 0);
      |             ~~~~~~~~~~^~~~~~~~~~~~~
      |                       |
      |                       <brace-enclosed initializer list>
./CPP_108.cpp:4:29: note:   initializing argument 1 of ‘int count_nums(std::vector<int>*)’
    4 | int count_nums(vector<int>* vec) {
      |                ~~~~~~~~~~~~~^~~
./CPP_108.cpp:47:23: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   47 |     assert (count_nums({1, 1, 2, -2, 3, 4, 5}) == 6);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
      |                       |
      |                       <brace-enclosed initializer list>
./CPP_108.cpp:4:29: note:   initializing argument 1 of ‘int count_nums(std::vector<int>*)’
    4 | int count_nums(vector<int>* vec) {
      |                ~~~~~~~~~~~~~^~~
./CPP_108.cpp:48:23: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   48 |     assert (count_nums({1, 6, 9, -6, 0, 1, 5}) == 5);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
      |                       |
      |                       <brace-enclosed initializer list>
./CPP_108.cpp:4:29: note:   initializing argument 1 of ‘int count_nums(std::vector<int>*)’
    4 | int count_nums(vector<int>* vec) {
      |                ~~~~~~~~~~~~~^~~
./CPP_108.cpp:49:23: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   49 |     assert (count_nums({1, 100, 98, -7, 1, -1}) == 4);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
      |                       |
      |                       <brace-enclosed initializer list>
./CPP_108.cpp:4:29: note:   initializing argument 1 of ‘int count_nums(std::vector<int>*)’
    4 | int count_nums(vector<int>* vec) {
      |                ~~~~~~~~~~~~~^~~
./CPP_108.cpp:50:23: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   50 |     assert (count_nums({12, 23, 34, -45, -56, 0}) == 5);
      |             ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
      |                       |
      |                       <brace-enclosed initializer list>
./CPP_108.cpp:4:29: note:   initializing argument 1 of ‘int count_nums(std::vector<int>*)’
    4 | int count_nums(vector<int>* vec) {
      |                ~~~~~~~~~~~~~^~~
./CPP_108.cpp:51:23: error: cannot convert ‘<brace-enclosed initializer list>’ to ‘std::vector<int>*’
   51 |     assert (count_nums({-0, 1}) == 1);
      |             ~~~~~~~~~~^~~~~~~~~
      |                       |
      |                       <brace-enclosed initializer list>
./CPP_108.cpp:4:29: note:   initializing argument 1 of ‘int count_nums(std::vector<int>*)’
    4 | int count_nums(vector<int>* vec) {
      |                ~~~~~~~~~~~~~^~~
./CPP_108.cpp:52:23: error: invalid conversion from ‘int’ to ‘std::vector<int>*’ [-fpermissive]
   52 |     assert (count_nums({1}) == 1);
      |             ~~~~~~~~~~^~~~~
      |                       |
      |                       int
./CPP_108.cpp:4:29: note:   initializing argument 1 of ‘int count_nums(std::vector<int>*)’
    4 | int count_nums(vector<int>* vec) {
      |                ~~~~~~~~~~~~~^~~


CPP_102.cpp: Compilation Failed
Error: ./CPP_102.cpp:24:5: error: redefinition of ‘int main()’
   24 | int main(){
      |     ^~~~
./CPP_102.cpp:13:5: note: ‘int main()’ previously defined here
   13 | int main() {
      |     ^~~~


CPP_142.cpp: Execution Failed
Error: CPP_142: ./CPP_142.cpp:16: int main(): Assertion `sum_squares({1,2,3}) == 6' failed.
Aborted (core dumped)


CPP_126.cpp: Execution Failed
Error: CPP_126: ./CPP_126.cpp:33: int main(): Assertion `is_sorted({1, 2, 2, 2, 3, 4}) == false' failed.
Aborted (core dumped)


Summary
=======
Total files processed: 72
Compilation failures: 36
Execution failures: 18
Assertion failures: 0

Detailed Results
===============
CPP_4.cpp Passed
CPP_109.cpp Compilation Failed
CPP_138.cpp Compilation Failed
CPP_12.cpp Compilation Failed
CPP_99.cpp Passed
CPP_42.cpp Compilation Failed
CPP_3.cpp Passed
CPP_121.cpp Compilation Failed
CPP_80.cpp Execution Failed
CPP_60.cpp Compilation Failed
CPP_139.cpp Execution Failed
CPP_63.cpp Compilation Failed
CPP_82.cpp Passed
CPP_159.cpp Compilation Failed
CPP_57.cpp Compilation Failed
CPP_133.cpp Passed
CPP_78.cpp Passed
CPP_64.cpp Execution Failed
CPP_13.cpp Passed
CPP_36.cpp Execution Failed
CPP_134.cpp Execution Failed
CPP_151.cpp Passed
CPP_157.cpp Passed
CPP_92.cpp Execution Failed
CPP_163.cpp Compilation Failed
CPP_135.cpp Compilation Failed
CPP_132.cpp Execution Failed
CPP_66.cpp Execution Failed
CPP_46.cpp Compilation Failed
CPP_53.cpp Compilation Failed
CPP_55.cpp Compilation Failed
CPP_61.cpp Passed
CPP_2.cpp Compilation Failed
CPP_75.cpp Compilation Failed
CPP_128.cpp Compilation Failed
CPP_62.cpp Compilation Failed
CPP_45.cpp Compilation Failed
CPP_77.cpp Compilation Failed
CPP_76.cpp Compilation Failed
CPP_35.cpp Passed
CPP_41.cpp Passed
CPP_71.cpp Passed
CPP_40.cpp Execution Failed
CPP_52.cpp Compilation Failed
CPP_8.cpp Execution Failed
CPP_98.cpp Execution Failed
CPP_23.cpp Passed
CPP_73.cpp Execution Failed
CPP_39.cpp Compilation Failed
CPP_43.cpp Execution Failed
CPP_91.cpp Execution Failed
CPP_49.cpp Compilation Failed
CPP_150.cpp Compilation Failed
CPP_136.cpp Execution Failed
CPP_9.cpp Compilation Failed
CPP_127.cpp Execution Failed
CPP_100.cpp Compilation Failed
CPP_24.cpp Compilation Failed
CPP_11.cpp Compilation Failed
CPP_96.cpp Compilation Failed
CPP_72.cpp Passed
CPP_114.cpp Compilation Failed
CPP_68.cpp Compilation Failed
CPP_59.cpp Compilation Failed
CPP_85.cpp Compilation Failed
CPP_97.cpp Passed
CPP_108.cpp Compilation Failed
CPP_56.cpp Passed
CPP_31.cpp Passed
CPP_102.cpp Compilation Failed
CPP_142.cpp Execution Failed
CPP_126.cpp Execution Failed
