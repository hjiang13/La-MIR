Sure, I can help you with that.

The control flow graph of the given IR code program can be represented as follows:
```dot
digraph {
    node[shape=box];
    
    b1[label="entry"];
    b2[label="getelementptr inbounds %\"class.std::vector\", %\"class.std::vector\"* %0, i64 0, i32 0, i32 0, i32 1"];
    b3[label="load i32*, i32** %2, align 8, !tbaa !3"];
    b4[label="getelementptr inbounds %\"class.std::vector\", %\"class.std::vector\"* %0, i64 0, i32 0, i32 0, i32 0, i32 0"];
    b5[label="load i32*, i32** %4, align 8, !tbaa !8"];
    b6[label="ptrtoint i32* %3 to i64"];
    b7[label="ptrtoint i32* %5 to i64"];
    b8[label="sub i64 %6, %7"];
    b9[label="icmp eq i64 %8, 0"];
    b10[label="br i1 %9, label %74, label %10"];
    b11[label="ashr exact i64 %8, 2"];
    b12[label="call i64 @llvm.umax.i64(i64 %11, i64 2)"];
    b13[label="add i64 %12, -1"];
    b14[label="lshr i64 %13, 1"];
    b15[label="add nuw i64 %14, 1"];
    b16[label="icmp ult i64 %13, 14"];
    b17[label="br i1 %16, label %70, label %18"];
    b18[label="and i64 %15, -8"];
    b19[label="shl i64 %18, 1"];
    b20[label="br label %21"];
    b21[label="phi i64 [ 0, %18 ], [ %64, %21 ]"];
    b22[label="phi <4 x i32> [ zeroinitializer, %18 ], [ %62, %21 ]"];
    b23[label="phi <4 x i32> [ zeroinitializer, %18 ], [ %63, %21 ]"];
    b24[label="shl i64 %21, 1"];
    b25[label="or i64 %24, 2"];
    b26[label="or i64 %24, 4"];
    b27[label="or i64 %24, 6"];
    b28[label="or i64 %24, 8"];
    b29[label="or i64 %24, 10"];
    b30[label="or i64 %24, 12"];
    b31[label="or i64 %24, 14"];
    b32[label="getelementptr inbounds i32, i32* %5, i64 %24"];
    b33[label="getelementptr inbounds i32, i32* %5, i64 %25"];
    b34[label="getelementptr inbounds i32, i32* %5, i64 %26"];
    b35[label="getelementptr inbounds i32, i32* %5, i64 %27"];
    b36[label="getelementptr inbounds i32, i32* %5, i64 %28"];
    b37[label="getelementptr inbounds i32, i32* %5, i64 %29"];
    b38[label="getelementptr inbounds i32, i32* %5, i64 %30"];
    b39[label="getelementptr inbounds i32, i32* %5, i64 %31"];
    b40[label="load i32, i32* %32, align 4, !tbaa !9"];
    b41[label="load i32, i32* %33, align 4, !tbaa !9"];
    b42[label="load i32, i32* %34, align 4, !tbaa !9"];
    b43[label="load i32, i32* %35, align 4, !tbaa !9"];
    b44[label="insertelement <4 x i32> poison, i32 %40, i32 0"];
    b45[label="insertelement <4 x i32> %44, i32 %41, i32 1"];
    b46[label="insertelement <4 x i32> %45, i32 %42, i32 2"];
    b47[label="insertelement <4 x i32> %46, i32 %43, i32 3"];
    b48[label="load i32, i32* %36, align 4, !tbaa !9"];
    b49[label="load i32, i32* %37, align 4, !tbaa !9"];
    b50[label="load i32, i32* %38, align 4, !tbaa !9"];
    b51[label="load i32, i32* %39, align 4, !tbaa !9"];
    b52[label="insertelement <4 x i32> poison, i32 %48, i32 0"];
    b53[label="insertelement <4 x i32> %52, i32 %49, i32 1"];
    b54[label="insertelement <4 x i32> %53, i32 %50, i32 2"];
    b55[label="insertelement <4 x i32> %54, i32 %51, i32 3"];
    b56[label="srem <4 x i32> %47, <i32 2, i32 2, i32 2, i32 2>"];
    b57[label="srem <4 x i32> %55, <i32 2, i32 2, i32 2, i32 2>"];
    b58[label="icmp eq <4 x i32> %56, <i32 1, i32 1, i32 1, i32 1>"];
    b59[label="icmp eq <4 x i32> %57, <i32 1, i32 1, i32 1, i32 1>"];
    b60[label="select <4 x i1> %58, <4 x i32> %47, <4 x i32> zeroinitializer"];
    b61[label="select <4 x i1> %59, <4 x i32> %55, <4 x i32> zeroinitializer"];
    b62[label="add <4 x i32> %60, %22"];
    b63[label="add <4 x i32> %61, %23"];
    b64[label="add nuw i64 %21, 8"];
    b65[label="icmp eq i64 %64, %18"];
    b66[label="br i1 %65, label %66, label %21, !llvm.loop !11"];
    b67[label="add <4 x i32> %63, %62"];
    b68[label="call i32 @llvm.vector.reduce.add.v4i32(<4 x i32> %67)"];
    b69[label="icmp eq i64 %15, %18"];
    b70[label="br i1 %69, label %74, label %71, !llvm.loop !11"];
    b71[label="phi i64 [ 0, %10 ], [ %18, %66 ]"];
    b72[label="phi i64 [ 0, %10 ], [ %19, %66 ]"];
    b73[label="phi i32 [ 0, %10 ], [ %68, %66 ]"];
    b74[label="phi i32 [ 0, %1 ], [ %68, %66 ], [ %85, %76 ]"];
    b75[label="ret i32 %75"];
    b76[label="phi i64 [ %86, %76 ], [ %71, %70 ]"];
    b77[label="phi i64 [ %87, %76 ], [ %72, %70 ]"];
    b78[label="phi i32 [ %85, %76 ], [ %73, %70 ]"];
    b79[label="getelementptr inbounds i32, i32* %5, i64 %78"];
    b80[label="load i32, i32* %80, align 4, !tbaa !9"];
    b81[label="srem i32 %81, 2"];
    b82[label="icmp eq i32 %82, 1"];
    b83[label="select i1 %83, i32 %81, i32 0"];
    b84[label="add nsw i32 %84, %79"];
    b85[label="icmp eq i64 %77, %14"];
    b86[label="br i1 %85, label %74, label %76, !llvm.loop !14"];
    b87[label="shl nuw nsw i64 %77, 1"];
    b88[label="icmp eq i64 %77, %14"];
    b89[label="br i1 %88, label %74, label %76, !llvm.loop !14"];
}
```
Note that the control flow graph is not complete, as it only shows the basic blocks that are relevant to the given input. The control flow graph can be further optimized and refined, but this should give you a good starting point.